{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "4f2827cf-f156-4ee6-8796-6aa43515a6a1",
   "metadata": {},
   "outputs": [
    {
     "ename": "ModuleNotFoundError",
     "evalue": "No module named 'gspread'",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mModuleNotFoundError\u001b[39m                       Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[1]\u001b[39m\u001b[32m, line 6\u001b[39m\n\u001b[32m      4\u001b[39m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mio\u001b[39;00m\n\u001b[32m      5\u001b[39m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mtraceback\u001b[39;00m\n\u001b[32m----> \u001b[39m\u001b[32m6\u001b[39m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mgspread\u001b[39;00m\n\u001b[32m      7\u001b[39m \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01moauth2client\u001b[39;00m\u001b[34;01m.\u001b[39;00m\u001b[34;01mservice_account\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m ServiceAccountCredentials\n\u001b[32m      8\u001b[39m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mdatetime\u001b[39;00m\n",
      "\u001b[31mModuleNotFoundError\u001b[39m: No module named 'gspread'"
     ]
    }
   ],
   "source": [
    "import streamlit as st\n",
    "import pandas as pd\n",
    "import re\n",
    "import io\n",
    "import traceback\n",
    "import gspread\n",
    "from oauth2client.service_account import ServiceAccountCredentials\n",
    "import datetime\n",
    "\n",
    "# --- Page config ---\n",
    "st.set_page_config(page_title=\"Mirror Trade App\", layout=\"wide\")\n",
    "\n",
    "# --- Helper functions ---\n",
    "def clean_name(s):\n",
    "    return re.sub(r'[^0-9a-zA-Z]+', '_', str(s)).strip('_').lower()\n",
    "\n",
    "def find_col(orig_cols, patterns):\n",
    "    if isinstance(patterns, str):\n",
    "        patterns = [patterns]\n",
    "    for pat in patterns:\n",
    "        pat_clean = clean_name(pat)\n",
    "        for c in orig_cols:\n",
    "            if clean_name(c) == pat_clean:\n",
    "                return c\n",
    "    return None\n",
    "\n",
    "def extract_quote(market_str):\n",
    "    s = str(market_str).upper().strip()\n",
    "    if \"-\" in s:\n",
    "        return s.split(\"-\")[-1]\n",
    "    common_quotes = [\"USDT\", \"BUSD\", \"USD\", \"ETH\", \"BTC\", \"INR\"]\n",
    "    for q in common_quotes:\n",
    "        if s.endswith(q):\n",
    "            return q\n",
    "    return s[-3:]\n",
    "\n",
    "# --- UI: instructions shown before upload ---\n",
    "st.title(\"üìä Mirror Trade Processor\")\n",
    "st.markdown(\n",
    "    \"**Important columns required BEFORE upload** ‚Äî make sure your file includes these headers (names can vary slightly):\"\n",
    ")\n",
    "st.info(\n",
    "    \"\"\"\n",
    "- **Market**  ‚Äî e.g. `BTC-USDT` or `USD-INR`  \n",
    "- **Date**    ‚Äî trade date  \n",
    "- **Trade Type** ‚Äî `BUY` or `SELL`  \n",
    "- **Quantity** ‚Äî numeric (only quantity)  \n",
    "- **Price** ‚Äî final per-unit price  \n",
    "- **Total** ‚Äî Quantity √ó Price\n",
    "\"\"\"\n",
    ")\n",
    "\n",
    "uploaded_file = st.file_uploader(\"üìÇ Upload your Excel file (.xlsx)\", type=[\"xlsx\"])\n",
    "\n",
    "if uploaded_file is None:\n",
    "    st.write(\"Upload a file to begin. The app will validate required columns and show warnings/errors.\")\n",
    "    st.stop()\n",
    "\n",
    "# --- Try reading the file ---\n",
    "try:\n",
    "    df_raw = pd.read_excel(uploaded_file, engine=\"openpyxl\")\n",
    "except Exception as e:\n",
    "    st.error(\"Failed to read the uploaded Excel file. Make sure it's a valid .xlsx file.\")\n",
    "    st.exception(e)\n",
    "    st.stop()\n",
    "\n",
    "orig_cols = df_raw.columns.tolist()\n",
    "st.subheader(\"Preview (first 5 rows)\")\n",
    "st.dataframe(df_raw.head(), height=220)\n",
    "\n",
    "# --- Detect columns using flexible matching ---\n",
    "col = {\n",
    "    \"market\": find_col(orig_cols, [\"market\", \"pair\", \"market_2\"]),\n",
    "    \"date\": find_col(orig_cols, [\"date\", \"trade date\", \"trade_date\"]),\n",
    "    \"trade_type\": find_col(orig_cols, [\"trade type\", \"trade_type\", \"side\", \"action\"]),\n",
    "    \"quantity\": find_col(orig_cols, [\"quantity\", \"qty\", \"totalvolume\", \"total_volume\"]),\n",
    "    \"price\": find_col(orig_cols, [\"price\", \"final price\", \"rate\", \"actualrate\"]),\n",
    "    \"total\": find_col(orig_cols, [\"total\", \"amount\", \"total_inr\", \"gross_amount\"]),\n",
    "    \"usd_inr\": find_col(orig_cols, [\"usd_inr_rate\", \"usd_inr\", \"usd-inr\", \"usd inr\"])\n",
    "}\n",
    "\n",
    "st.write(\"Detected columns (automatically matched):\")\n",
    "for k, v in col.items():\n",
    "    st.write(f\"- **{k}** -> `{v}`\")\n",
    "\n",
    "# --- Validate required columns ---\n",
    "required = [\"market\", \"date\", \"trade_type\", \"quantity\", \"price\", \"total\"]\n",
    "missing = [r for r in required if col.get(r) is None]\n",
    "if missing:\n",
    "    st.error(\"‚ùå Required column(s) missing: \" + \", \".join(missing))\n",
    "    st.warning(\"Please rename your Excel headers or add these columns and re-upload.\")\n",
    "    st.stop()\n",
    "\n",
    "# --- Process file with error handling ---\n",
    "try:\n",
    "    df = df_raw.copy()\n",
    "\n",
    "    mkt_col = col[\"market\"]\n",
    "    tt_col = col[\"trade_type\"]\n",
    "    qty_col = col[\"quantity\"]\n",
    "    price_col = col[\"price\"]\n",
    "    total_col = col[\"total\"]\n",
    "    date_col = col[\"date\"]\n",
    "    usd_col = col[\"usd_inr\"]\n",
    "\n",
    "    # Separate INR pairs and non-INR pairs\n",
    "    is_inr = df[mkt_col].astype(str).str.upper().str.endswith(\"INR\")\n",
    "    df_inr = df[is_inr].copy()\n",
    "    df_non_inr = df[~is_inr].copy()\n",
    "\n",
    "    if df_non_inr.empty:\n",
    "        st.info(\"No non-INR rows found ‚Äî nothing to mirror. You can download the original file.\")\n",
    "        towrite = io.BytesIO()\n",
    "        df.to_excel(towrite, index=False, engine=\"openpyxl\")\n",
    "        towrite.seek(0)\n",
    "        st.download_button(\n",
    "            \"‚¨áÔ∏è Download original file\",\n",
    "            data=towrite,\n",
    "            file_name=\"original_no_nonINR.xlsx\",\n",
    "            mime=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n",
    "        )\n",
    "        st.stop()\n",
    "\n",
    "    # Prepare mirrored rows\n",
    "    mirrored = df_non_inr.copy()\n",
    "    mirrored[\"__quote__\"] = mirrored[mkt_col].apply(extract_quote)\n",
    "    mirrored[mkt_col] = mirrored[\"__quote__\"] + \"INR\"\n",
    "\n",
    "    # Flip buy/sell\n",
    "    mirrored[tt_col] = mirrored[tt_col].astype(str).str.upper().apply(\n",
    "        lambda x: \"BUY\" if x == \"SELL\" else (\"SELL\" if x == \"BUY\" else x)\n",
    "    )\n",
    "\n",
    "    # If USD-INR column exists, convert Price and Total\n",
    "    if usd_col:\n",
    "        try:\n",
    "            mirrored[price_col] = pd.to_numeric(mirrored[price_col], errors=\"coerce\") * pd.to_numeric(mirrored[usd_col], errors=\"coerce\")\n",
    "            mirrored[total_col] = pd.to_numeric(mirrored[total_col], errors=\"coerce\") * pd.to_numeric(mirrored[usd_col], errors=\"coerce\")\n",
    "            mirrored[usd_col] = 1\n",
    "        except Exception:\n",
    "            st.warning(\"Could not compute exact INR Price/Total. Mirrored Price/Total may contain NaNs.\")\n",
    "    else:\n",
    "        st.warning(\"No USD-INR rate column found. Mirrored INR Price/Total cannot be computed precisely.\")\n",
    "\n",
    "    mirrored.drop(columns=[\"__quote__\"], inplace=True, errors=\"ignore\")\n",
    "\n",
    "    # Combine original and mirrored\n",
    "    final_df = pd.concat([df, mirrored], ignore_index=True, sort=False)\n",
    "\n",
    "    # Sort by date if possible\n",
    "    try:\n",
    "        final_df[date_col] = pd.to_datetime(final_df[date_col], errors=\"coerce\")\n",
    "        final_df = final_df.sort_values(by=date_col).reset_index(drop=True)\n",
    "    except Exception:\n",
    "        pass\n",
    "\n",
    "    # --- Google Sheets Integration ---\n",
    "    scope = [\"https://spreadsheets.google.com/feeds\",\n",
    "             \"https://www.googleapis.com/auth/drive\"]\n",
    "    creds = ServiceAccountCredentials.from_json_keyfile_name(\"google_sheets_key.json\", scope)\n",
    "    client = gspread.authorize(creds)\n",
    "\n",
    "    sheet_id = \"15s9U7fAJw4Un4y3XV-xUnLe2hlkoFAZdzrUSexQ3he0\"  # Your Sheet ID\n",
    "    spreadsheet = client.open_by_key(sheet_id)\n",
    "    worksheet = spreadsheet.sheet1\n",
    "\n",
    "    # Add timestamp\n",
    "    final_df[\"Saved_At\"] = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n",
    "\n",
    "    # Append data instead of overwriting\n",
    "    existing_data = worksheet.get_all_values()\n",
    "    start_row = len(existing_data) + 1\n",
    "    new_data = final_df.values.tolist()\n",
    "    worksheet.update(f\"A{start_row}\", new_data)\n",
    "\n",
    "    st.success(\"‚úÖ Data also saved to Google Sheets\")\n",
    "\n",
    "    # --- Provide final downloadable file ---\n",
    "    out_buffer = io.BytesIO()\n",
    "    final_df.to_excel(out_buffer, index=False, engine=\"openpyxl\")\n",
    "    out_buffer.seek(0)\n",
    "    st.success(\"‚úÖ Processing complete. You can download the processed file below.\")\n",
    "    st.download_button(\n",
    "        label=\"‚¨áÔ∏è Download Mirrored Output\",\n",
    "        data=out_buffer,\n",
    "        file_name=\"output_trades_with_mirrors.xlsx\",\n",
    "        mime=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n",
    "    )\n",
    "    st.balloons()\n",
    "\n",
    "except Exception as exc:\n",
    "    st.error(\"‚ö†Ô∏è An error occurred while processing the file.\")\n",
    "    st.exception(traceback.format_exc())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d863425a-a296-4807-802d-55a87f12fd3d",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python (hyd_env)",
   "language": "python",
   "name": "hyd_env"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
